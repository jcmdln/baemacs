# -*- mode : org -*-
#+TITLE: Baemacs - A Literate GNU/Emacs Configuration
#+STARTUP: indent
#+LANGUAGE: en

Baemacs is yet another take on a literate GNU/Emacs configuration that
intends to remain close to the default behavior and appearance.

#+HTML: <p align="center"><img src="img/baemacs.png" /></p>

To understand what Baemacs is attempting to do differently, let's cover
some of the important goals and intentions of this configuration.

1. Preserve (most) core GNU/Emacs functionality

  Unlike other configurations, there is no evil-mode support and we
  don't remap any (useful) default keybinds.  If you are comfortable
  with plain GNU/Emacs, you should feel empowered by Baemacs.

  Vi/Vim and evil-mode users should most likely look at one of the many
  alternatives that provides or defaults to evil-mode.

2. Fully document changes with context and reasoning (eventually)

   Having documentation, context of why something was added, and
   reasoning of whether it is a good/bad/subjective addition allows you
   as the user to better understand how each component ties together.

   Even better, you don't need to hunt any of this down, it's all in
   this file!

3. Leverage use-package for predictability

   Creating logic of when packages should conditionally be loaded is a
   bit easier with use-package.  Also it reads a little better than
   huge blocks of elisp.

4. Performance is a concern, though avoid voodoo

   There's two things done in this configuration that appear to impact
   performance in a positive way:

   - Tweaking the garbage collector

     This is primarily to decrease garbage collection pauses, but the
     changes made will at minimum halve the number of pauses we
     experience. See [[#garbage-collection][Garbage Collection]] for clarification.

   - Compiling configuration files

     This is primarily to decrease initialization time.  When using a
     non-Org config might ordinarily change an '.el' file, expecting
     that change to be reflected on startup.  In reality if you didn't
     byte-compile your configuration after making changes, you would
     inherit the value from '.elc', which is no longer the expected
     behavior.  There may be some other implications though this is the
     main argument I've heard against byte-compiling config files.

     In our case since everything should be in 'README.org', which acts
     as our staging ground for changes, we may tangle and byte-compile
     configuration files with less apprehension.

* Table of Contents :TOC_4:noexport:
- [[#usage][Usage]]
  - [[#install][Install]]
  - [[#configure][Configure]]
  - [[#maintain][Maintain]]
- [[#configuration-files][Configuration Files]]
  - [[#initel][init.el]]
    - [[#garbage-collection][Garbage Collection]]
      - [[#gc-cons-percentage][gc-cons-percentage]]
      - [[#gc-cons-threshold][gc-cons-threshold]]
    - [[#custom][Custom]]
    - [[#encoding][Encoding]]
    - [[#environment][Environment]]
    - [[#appearance][Appearance]]
      - [[#disable-toolbars][Disable toolbars]]
      - [[#disable-splash-screen][Disable splash screen]]
      - [[#re-use-frames-and-windows][Re-use Frames and Windows]]
      - [[#font][Font]]
      - [[#theme][Theme]]
    - [[#editing][Editing]]
      - [[#clipboard][Clipboard]]
      - [[#scrolling][Scrolling]]
      - [[#line-numbers][Line Numbers]]
      - [[#modeline][Modeline]]
      - [[#parenthesis-matching][Parenthesis Matching]]
      - [[#whitespace][Whitespace]]
      - [[#word-wrap][Word Wrap]]
    - [[#input][Input]]
      - [[#keyboard][Keyboard]]
      - [[#mouse][Mouse]]
    - [[#package-management][Package Management]]
      - [[#use-package][use-package]]
      - [[#no-littering][no-littering]]
    - [[#bootstrap][Bootstrap]]
  - [[#configel][config.el]]
    - [[#packages][Packages]]
      - [[#async][async]]
      - [[#auto-compile][auto-compile]]
      - [[#circe][circe]]
      - [[#clang-format][clang-format]]
      - [[#company][company]]
      - [[#counsel][counsel]]
      - [[#diff-hl][diff-hl]]
      - [[#dimmer][dimmer]]
      - [[#eglot][eglot]]
      - [[#eldoc][eldoc]]
      - [[#elfeed][elfeed]]
      - [[#eshell][eshell]]
      - [[#eww][eww]]
      - [[#flycheck][flycheck]]
      - [[#flyspell][flyspell]]
      - [[#gnus][gnus]]
      - [[#helpful][helpful]]
      - [[#highlight-indent-guides][highlight-indent-guides]]
      - [[#ibuffer][ibuffer]]
      - [[#ivy][ivy]]
      - [[#magit][magit]]
      - [[#nov][nov]]
      - [[#package-utils][package-utils]]
      - [[#rainbow-delimiters][rainbow-delimiters]]
      - [[#ranger][ranger]]
      - [[#scratch][scratch]]
      - [[#server][server]]
      - [[#smartparens][smartparens]]
      - [[#undo-tree][undo-tree]]
      - [[#xclip][xclip]]
      - [[#yasnippet][yasnippet]]
    - [[#languages][Languages]]
      - [[#ansible][Ansible]]
      - [[#apache][Apache]]
      - [[#c][C]]
      - [[#c-1][C++]]
      - [[#caddy][Caddy]]
      - [[#cmake][CMake]]
      - [[#d][D]]
      - [[#docker][Docker]]
      - [[#dotenv][DotEnv]]
      - [[#gdscript][GDScript]]
      - [[#git][Git]]
      - [[#go][Go]]
      - [[#jinja2][Jinja2]]
      - [[#json][JSON]]
      - [[#lisp][Lisp]]
      - [[#lua][Lua]]
      - [[#markdown][Markdown]]
      - [[#meson][Meson]]
      - [[#nginx][NGINX]]
      - [[#ninja][Ninja]]
      - [[#org][Org]]
      - [[#php][PHP]]
      - [[#protobuf][Protobuf]]
      - [[#python][Python]]
      - [[#rust][Rust]]
      - [[#yaml][YAML]]

* Usage

This singular file is all that is needed to fully replicate this
configuration.  While you may simply download a copy of this file and
place it within ~/.emacs.d, the steps below will reflect using git to
retrieve and manage your copy of the configuration.

** Install

Be sure to move any existing ~/.emacs{,.d} before performing the
following steps.

First, clone this repository:

#+BEGIN_SRC shell :eval no :tangle no
  $ git clone https://gitlab.com/jcmdln/baemacs.git
#+END_SRC

Create a symlink to '~/.emacs.d':

#+BEGIN_SRC shell :eval no :tangle no
  $ ln -sf $(pwd)/baemacs ~/.emacs.d
#+END_SRC

** Configure

There are two ways of loading the configuration, either of which are
perfectly suitable depending on personal preference.

Configure by evaluating this file via command line:

#+BEGIN_SRC shell :eval no :export no :tangle no
  $ emacs --eval='(org-babel-load-file "~/.emacs.d/README.org")'
#+END_SRC

OR

Configure by loading this file within Emacs:

#+BEGIN_SRC emacs-lisp :eval no :export no :tangle no
  M-x org-babel-load-file RET ~/.emacs.d/README.org
#+END_SRC

** Maintain

Ideally you would have your own fork and modify this file how you see
fit, managing portability between systems with some VCS like git.

There is no right or wrong way, so I'll leave this section ambiguous
for now.

* Configuration Files

To make the most effective use of the various startup files that Emacs
will check for, each file listed in this section will detail the changes
they contain.  The intention is to ensure that we don't force Emacs to
load everything during initialization, instead loading the following
configuration file at the end of initialization.

** init.el

Emacs will look for this specific file once it reaches the
initialization phase.  Here we will make modifications to things that
ship with Emacs and should be changed early.

#+BEGIN_SRC emacs-lisp :tangle init.el
;;; init.el ---- Baemacs initialization file
;;; Commentary:
;; Emacs will look for this specific file once it reaches the
;; initialization phase.  Here we will make modifications to things that
;; ship with Emacs and should be changed early.
;;; Code:
#+END_SRC

*** Garbage Collection

Emacs makes some considerations for older and more memory restricted
systems in terms of how the garbage collector is configured.  On modern
64-bit systems these considerations may be far too conservative for
users who run many elisp programs such as gnus, elfeed, circe, etc.

As Emacs develops its concurrency, parallelism, and events primitives
these adjustments will need to be revisited.  Note that for memory
constrained environments you may want to disable the changes to the
garbage collector made in this section.

**** gc-cons-percentage

For the purposes of initialization, we'll increase `gc-cons-percentage`
to decrease garbage collection pauses.  The settings below mean that
garbage collection is deferred until reaching 80% of the total heap
size.  After initialization completes we lower this value to 20% of
the total heap size to prevent garbage collection passes from becoming
too large to be handled quickly.

At the time of writing, the default is 10% so we are effectively
attempting to halve the amount of garbage collection pauses we would
experience as a result of reaching the defined threshold of the total
heap size.

Should you want to compare against the default value, we preserve it as
shown below:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar gc-cons-percentage-default)
  (defvar gc-cons-percentage-init)
  (defvar gc-cons-percentage-tuned)

  (setq gc-cons-percentage-default gc-cons-percentage
        gc-cons-percentage-init    0.8
        gc-cons-percentage-tuned   0.2
        gc-cons-percentage         gc-cons-percentage-init)

  (add-hook 'after-init-hook
            (lambda ()
              (setq gc-cons-percentage gc-cons-percentage-tuned)
              (garbage-collect)))
#+END_SRC

**** gc-cons-threshold

Now we will increase the `gc-cons-threshold`, which refers to the total
bytes of storage for lisp objects that must be allocated to trigger
subsequent garbage collections.  On 32-bit systems this threshold is
400000 objects, while on 64-bit systems it is 800000 objects.

Modifying this value is generally not recommended and considered an act
of performance voodoo, though the idea is that by specifying a larger
threshold, garbage collection will occur less often, meaning fewer GC
pauses. We'll set this value to 200000 globally, which ideally will
reduce the total number of GC pauses we experience by more than half.

The default value is also stored so you may evaluate this change as
shown below:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar gc-cons-threshold-default)
  (defvar gc-cons-threshold-tuned)

  (setq gc-cons-threshold-default gc-cons-threshold
        gc-cons-threshold-tuned   (* 1000 1000 2)
        gc-cons-threshold         gc-cons-threshold-tuned)
#+END_SRC

*** Custom

Rather than Emacs customization being appended to the end of the
configuration file, in our case 'init.el', we may specify the location
of `custom-file` early on to keep ~/.emacs.d relatively clean.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq custom-file "~/.config/emacs/custom.el")
#+END_SRC

*** Encoding

Another thing we want to handle very early is attempting to enforce the
use of UTF-8 encoding.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar prefer-coding-system)
  (defvar set-default-coding-systems)
  (defvar set-language-environment)
  (defvar set-locale-environment)

  (setq prefer-coding-system       'utf-8
        set-default-coding-systems 'utf-8
        set-language-environment   "UTF-8"
        set-locale-environment     "en_US.UTF-8")
#+END_SRC

*** Environment

Emacs will inherit your system's current environment, though we may
adjust some key variables for quality of life.

- Set Emacs as our default EDITOR when in Emacs
- Set PAGER to an Emacs built-in, which doesn't require ansi-term
- Unset PROMPT_COMMAND, which causes issues with ssh connections
- Attempt to get/set variables, in case they differ

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setenv "EDITOR"         "emacsclient")
  (setenv "GIT_EDITOR"     "emacsclient")
  (setenv "MANPATH"        (getenv "MANPATH"))
  (setenv "PAGER"          "cat")
  (setenv "PATH"           (getenv "PATH"))
  (setenv "PROMPT_COMMAND" "")
  (setenv "SHELL"          (getenv "SHELL"))
  (setenv "TERM"           (getenv "TERM"))
#+END_SRC

*** Appearance

In terms of appearance, I prefer to have as little wasted space and
visual clutter as possible.  I make no attempt to completely restyle
Emacs, preferring instead to make slight modifications.

**** Disable toolbars

I don't find the toolbars to be useful comparatively to the amount of
visual space they consume.  The following will disable the various
toolbars when their functions are bound, which prevents them from ever
being initialized:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (when (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (when (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
#+END_SRC

**** Disable splash screen

After initialization completes, we'll end up with some clutter that is
not very helpful for long-time Emacs users.

- Remove the default scratch buffer message
- Disable the splash screen
- Disable the startup buffer menu

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq initial-scratch-message     ""
        inhibit-splash-screen       t
        inhibit-startup-buffer-menu t)
#+END_SRC

**** Re-use Frames and Windows

One big annoyance is Emacs arbitrary splitting my window to show a
newly created buffer.  This is especially annoying when I run a command
myself such as 'M-x man' which causes arbitrary splits.

Here we will enforce always re-using the currently selected frame when
a new buffer is opened or focused.  This works in most cases, though as
shown below certain things like 'man' will not respect our choices and
require specific adjustment.  Some things like 'gnus' should still make
splits as they want, so we won't look for every possible edge condition
to normalize this behavior.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-to-list 'display-buffer-alist
               '("*Help*" display-buffer-same-window))

  (add-to-list 'display-buffer-alist
               '("*Man*" display-buffer-same-window))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar reusable-frames)
  (defvar Man-notify-method)

  (setq pop-up-frames     nil
        pop-up-windows    nil
        reusable-frames   't
        Man-notify-method 'pushy)
#+END_SRC

**** Font

This probably isn't needed, but we'll set the default font to the
system-defined Monospace font.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (set-face-attribute :family "Monospace")
#+END_SRC

**** Theme

Rather than include yet another theme, we'll use the tango-dark theme.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (load-theme 'tango-dark)
#+END_SRC

*** Editing

There are some general-purpose changes to make for editing files, which
ideally if I ever get around to incorporating site-start.el will allow
loading a slim, nimble instance of Emacs when needed.  For now I'll
leave these changes here.

**** Clipboard

This part is a bit unorganized though reduces clutter by inhibiting
buffers and adjusting how Emacs' clipboard works.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq save-interprogram-paste-before-kill t
        select-enable-primary               nil)
#+END_SRC

**** Scrolling

- Scroll line-by-line
- Preserve the cursor position when scrolling
- No scroll margins
- Don't scroll past the end of a buffer

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq auto-window-vscroll             nil
        scroll-conservatively           101
        scroll-margin                   0
        scroll-preserve-screen-position 1
        scroll-step                     1
        scroll-up-aggressively          0.0
        scroll-down-aggressively        0.0)
#+END_SRC

**** Line Numbers

Display line numbers in most types of modes where it makes sense.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'conf-mode-hook 'display-line-numbers-mode)
  (add-hook 'lisp-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (add-hook 'org-mode-hook  'display-line-numbers-mode)
  (add-hook 'text-mode-hook 'display-line-numbers-mode)
#+END_SRC

**** Modeline

- Show column numbers
- Ensure '\n' always precedes EOF
- When show-paren-mode is enabled, delay showing match for 330ms
- Disable the visual-bell

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar show-paren-delay)

  (setq column-number-mode    t
        require-final-newline t
        show-paren-delay      0.33
        visible-bell          nil)
#+END_SRC

**** Parenthesis Matching

Highlight matching parenthesis, always.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook
            (lambda()
              (show-paren-mode t)))
#+END_SRC

**** Whitespace

Before saving, remove any trailing whitespace characters.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

**** Word Wrap

When Visual Line mode is enabled, ‘word-wrap’ is turned on in this
buffer, and simple editing commands are redefined to act on visual
lines, not logical lines.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook
            (lambda()
              (global-visual-line-mode t)))
#+END_SRC

*** Input

I do make some minor changes to input methods, though I intend to remain
as faithful to "the Emacs way" as I can.

**** Keyboard

In terms of keyboard input, I only make slight adjustments though their
usefulness is highly subjective.

****** Keybinds

From my time of using tmux + vim I had grown to prefer some custom
keybinds I made for handling splits or navigating through panes. Here
I've attempted to recreated the subjective ease of navigation I prefer:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-set-key (kbd "M--")
                  (lambda()
                    (interactive)
                    (split-window-vertically)
                    (other-window 1 nil)
                    (switch-to-next-buffer)))

  (global-set-key (kbd "M-=")
                  (lambda()
                    (interactive)
                    (split-window-horizontally)
                    (other-window 1 nil)
                    (switch-to-next-buffer)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-set-key (kbd "C-c c")     'comment-or-uncomment-region)
  (global-set-key (kbd "<M-down>")  'windmove-down)
  (global-set-key (kbd "<M-left>")  'windmove-left)
  (global-set-key (kbd "<M-right>") 'windmove-right)
  (global-set-key (kbd "<M-up>")    'windmove-up)
#+END_SRC

**** Mouse

In terms of the mouse, I really only adjust scrolling behavior and add
xterm support:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar mouse-wheel-follow-mouse)
  (defvar mouse-wheel-progressive-speed)
  (defvar mouse-wheel-scroll-amount)

  (setq mouse-wheel-follow-mouse      't
        mouse-wheel-progressive-speed nil
        mouse-wheel-scroll-amount     '(1 ((shift) . 1))
        mouse-yank-at-point           t)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook
            (lambda()
              (xterm-mouse-mode 1)))

  (global-set-key (kbd "<mouse-4>")
                  (lambda()
                    (interactive)
                    (scroll-down-line 3)))

  (global-set-key (kbd "<mouse-5>")
                  (lambda()
                    (interactive)
                    (scroll-up-line 3)))
#+END_SRC

*** Package Management

Package management isn't loaded by default, so we have to explicitly
require it be loaded now:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (require 'package)
#+END_SRC

Here we're defining where to put packages, where we should get packages
from, and the priority we should retrieve packages if a package with the
same name exists on multiple sources.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq package-user-dir "~/.config/emacs/pkg/"
        package-archives
        '(("elpa"         . "https://elpa.gnu.org/packages/")
          ("melpa-stable" . "https://stable.melpa.org/packages/")
          ("melpa"        . "https://melpa.org/packages/"))
        package-archive-priorities
        '(("elpa"         . 3)
          ("melpa-stable" . 2)
          ("melpa"        . 1))
        package-pinned-packages '((use-package . "melpa")))
#+END_SRC

With the above changes made, we may now initialize the package module:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (package-initialize)
#+END_SRC

**** use-package

The first package we'll ensure exists is use-package, which the rest of
this file relies on for handling per-package configuration.  In newer
versions of Emacs use-package is now a built-in, but we should check to
be nice to older versions:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package)
    (require 'bind-key))
#+END_SRC

Some decent use-package tweaks are to defer loading a package unless
demanded, ensure a package exists or can be retrieved before loading
its configuration, and check that use-package is installed and active
before attempting to initialize:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq use-package-always-defer      t
        use-package-always-ensure     t
        use-package-check-before-init t)
#+END_SRC

**** no-littering

The second package will keep our ~/.emacs.d nice and tidy by adjusting
the locations of configuration files.  It uses a unixy format, which is
a nice change.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package no-littering
    :demand t
    :commands (no-littering-expand-var-file-name)
    :config
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))))
#+END_SRC

*** Bootstrap

Something we can do to slightly improve the total duration needed for
Emacs to complete its initialization phase is byte-compile the
configuration files we create.  If performed conditionally, we only
have to pay the cost of byte-compiling when we make a change to this
configuration file for the entire configuration to be rebuilt.

At the end of initialization, ensure that 'README.org' is not newer
than 'config.el', otherwise rebuild our configuration files and
byte-compile them.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun emacs-reconfig()
    "Build and compile 'org-mode' config."
    (interactive)
    (require 'org)
    (org-babel-load-file "~/.config/emacs/README.org")
    (byte-compile-file   "~/.config/emacs/init.el")
    (byte-compile-file   "~/.config/emacs/config.el"))

  (if (file-newer-than-file-p "~/.config/emacs/README.org"
                              "~/.config/emacs/config.el")
      (emacs-reconfig)
    (load "~/.config/emacs/config.el"))
#+END_SRC

** config.el

This is a non-standard file that is referenced at the end of 'init.el'
which contains our extra package and language definitions.

Before we add anything to this file, first we'll add the file header:

#+BEGIN_SRC emacs-lisp :tangle config.el
;;; config.el ---- Baemacs configuration file
;;; Commentary:
;; This is a non-standard file that is referenced at the end of 'init.el'
;; which contains our extra package and language definitions.
;;; Code:
#+END_SRC

*** Packages

**** async

Simplify calling asynchronous functions and processes.  See the
documentation for `async-start' and `async-start-process' for more
information.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package async
    :config (async-bytecomp-package-mode '(all)))
#+END_SRC

**** auto-compile

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package auto-compile
    :commands (auto-compile-on-load-mode auto-compile-on-save-mode)
    :config
    (auto-compile-on-load-mode)
    (auto-compile-on-save-mode))
#+END_SRC

**** circe

This package adds _another_ IRC client, which is my preferred client
even over irssi, weechat, or other clients I've used in the past.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package circe
    :commands (enable-lui-logging-globally lui-set-prompt)
    :init
    (add-hook 'circe-server-mode-hook (lambda() (require 'circe-chanop)))
    (add-hook 'circe-chat-mode-hook
              (lambda()
                (lui-set-prompt
                 (concat (propertize
                          (concat (buffer-name) ":")
                          'face 'circe-prompt-face)
                         " "))))

    (add-hook 'lui-mode-hook
              (lambda()
                (setq fringes-outside-margins t
                      left-margin-width       9
                      word-wrap               t
                      wrap-prefix             "")))

    :config
    (defvar lui-flyspell-p)
    (defvar lui-logging-directory)

    (setq circe-default-part-message ""
          circe-default-quit-message ""
          circe-format-server-topic  "*** Topic: {userhost}: {topic-diff}"
          circe-reduce-lurker-spam   t
          circe-use-cycle-completion t

          lui-fill-type              nil
          lui-flyspell-alist         '((".*" "american"))
          lui-flyspell-p             t
          lui-logging-directory      "~/.config/emacs/var/circe"
          lui-time-stamp-format      "%H:%M:%S"
          lui-time-stamp-position    'left-margin)

    (load "lui-logging" nil t)
    (enable-lui-logging-globally)
    (enable-circe-color-nicks)

    (if (file-exists-p "~/.config/emacs/usr/circe.el")
        (load-file     "~/.config/emacs/usr/circe.el")))
#+END_SRC

**** clang-format

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package clang-format)
#+END_SRC

**** company

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company
    :hook ((lisp-mode prog-mode text-mode) . company-mode)
    :config
    (setq company-tooltip-limit  20
          company-idle-delay     0.3
          company-echo-delay     0
          company-begin-commands '(self-insert-command)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company-c-headers
    :after (company)
    :config (add-to-list 'company-backends 'company-c-headers))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company-emoji
    :if window-system
    :after (company))
#+END_SRC

**** counsel

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package counsel
    :bind
    (("<f1> f"  . counsel-describe-function)
     ("<f1> l"  . counsel-find-library)
     ("<f1> v"  . counsel-describe-variable)
     ("<f2> i"  . counsel-info-lookup-symbol)
     ("<f2> u"  . counsel-unicode-char)
     ("C-s"     . counsel-grep-or-swiper)
     ("C-c g"   . counsel-git)
     ("C-c j"   . counsel-git-grep)
     ("C-c l"   . counsel-ag)
     ("C-r"     . counsel-minibuffer-history)
     ("C-x C-f" . counsel-find-file)
     ("C-x l"   . counsel-locate)
     ("M-x"     . counsel-M-x)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package swiper
    :demand t)
#+END_SRC

**** diff-hl

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package diff-hl
    :demand t
    :commands (diff-hl-mode diff-hl-margin-mode)
    :hook ((conf-mode org-mode prog-mode text-mode) . diff-hl-mode)
    :init
    (when (eq window-system nil)
      (add-hook 'after-init-hook
                (lambda()
                  (add-hook 'conf-mode-hook 'diff-hl-margin-mode)
                  (add-hook 'org-mode-hook  'diff-hl-margin-mode)
                  (add-hook 'prog-mode-hook 'diff-hl-margin-mode)
                  (add-hook 'text-mode-hook 'diff-hl-margin-mode)))))
#+END_SRC

**** dimmer

This package provides a minor mode which dims inactive buffers, namely
the buffers the cursor is not currently active in. It can be helpful
for those who use many buffers.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package dimmer
    :commands (dimmer-mode)
    :hook (after-init . dimmer-mode))
#+END_SRC

**** eglot

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eglot
    :commands (eglot-ensure)
    :hook ((c-mode c++-mode go-mode python-mode rust-mode) . 'eglot-ensure)
    :config
    (add-to-list 'eglot-server-programs '(c-mode . ("clangd")))
    (add-to-list 'eglot-server-programs '(c++-mode . ("clangd")))
    (add-hook 'eglot-managed-mode-hook
              (lambda()
                (add-hook 'before-save-hook 'eglot-format-buffer nil 'local)))

    (setq eglot-auto-display-help-buffer nil
          eglot-put-doc-in-help-buffer   nil))
#+END_SRC

**** eldoc

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eldoc
    :commands (global-eldoc-mode)
    :init (global-eldoc-mode -1))
#+END_SRC

**** elfeed

This package provides an extensible web feed reader, supporting both
RSS and Atom.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package elfeed
    :bind ("C-x w" . elfeed)
    :config
    (defvar elfeed-search-filter)

    (setq elfeed-search-filter "@1-week-ago +unread "
          url-queue-timeout    10)

    (if (file-exists-p "~/.config/emacs/usr/elfeed.el")
        (load-file     "~/.config/emacs/usr/elfeed.el")))
#+END_SRC

**** eshell

The default configuration of eshell is, well, bad. The ordinary user who
opens it once and considers it to be a bad tool is missing out of the
full potential eshell provides. I've spent a _lot_ of time making eshell
behave and look like typical unix shells, so maybe try it for yourself.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eshell
    :commands (eshell eshell/basename eshell/clear eshell/pwd)
    :config
    (defvar eshell-banner-message)
    (defvar eshell-cmpl-cycle-completions)
    (defvar eshell-hist-ignoredups)
    (defvar eshell-history-size)
    (defvar eshell-save-history-on-exit)
    (defvar eshell-prompt-regexp)
    (defvar eshell-prompt-function)
    (defvar eshell-visual-commands)

    (defun baemacs/eshell-prompt-function()
      (interactive)
      (lambda ()
        (concat "[" (user-login-name) "@"
                (car (split-string (system-name) "\\.")) " "
                (if (string= (eshell/pwd) (getenv "HOME"))
                    "~" (eshell/basename (eshell/pwd))) "]"
                (if (= (user-uid) 0) "# " "$ "))))

    (setq eshell-banner-message             ""
          eshell-cmpl-cycle-completions     nil
          eshell-error-if-no-glob           t
          eshell-hist-ignoredups            t
          eshell-history-size               4096
          eshell-prefer-lisp-functions      t
          eshell-prompt-function            (baemacs/eshell-prompt-function)
          eshell-prompt-regexp              "^[^#$\n]*[#$] "
          eshell-save-history-on-exit       t
          eshell-scroll-to-bottom-on-input  nil
          eshell-scroll-to-bottom-on-output nil
          eshell-scroll-show-maximum-output nil

          eshell-visual-commands
          '("alsamixer" "atop" "htop" "less" "mosh" "nano" "ssh" "tail"
            "top" "vi" "vim" "watch"))

    (add-hook 'eshell-mode-hook
              (lambda ()
                (defun eshell/clear()
                  "Hide previous scrollback to provide a clear view."
                  (interactive)
                  (recenter 0))))

    (defun eshell-new()
      "Open a new instance of eshell."
      (interactive)
      (eshell 'N)))
#+END_SRC

**** eww

I like eww, but it was missing a few things for me to use it as my
primary browser for non-interactive sites. Here we will ensure that eww
is our primary browser when visiting links, and that images are blocked
by default. Should you have multiple eww buffers open and want to
toggle displaying images in a specific buffer, you may now do so.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eww
    :commands (eww eww-mode eww-reload eww-toggle-images eww-new)
    :init (setq browse-url-browser-function 'eww-browse-url)
    :config
    (when window-system
      (setq shr-blocked-images "")

      (defun eww-toggle-images()
        "Toggle blocking images in eww."
        (interactive)
        (if (bound-and-true-p shr-blocked-images)
            (setq-local shr-blocked-images nil)
          (setq-local shr-blocked-images ""))
        (eww-reload)))

    (defun eww-new()
      "Open a new instance of eww."
      (interactive)
      (let ((url (read-from-minibuffer "Enter URL or keywords: ")))
        (switch-to-buffer (generate-new-buffer "*eww*"))
        (eww-mode)
        (eww url))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eww-lnum
    :after eww
    :commands (eww-lnum-follow eww-lnum-universal)
    :bind
    (:map eww-mode-map
          ("f" . eww-lnum-follow)
          ("F" . eww-lnum-universal)))
#+END_SRC

**** flycheck

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flycheck
    :demand t
    :hook (prog-mode . flycheck-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flycheck-inline
    :demand t
    :commands (turn-on-flycheck-inline)
    :hook (flycheck-mode . turn-on-flycheck-inline))
#+END_SRC

**** flyspell

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flyspell
    :hook
    ((markdown-mode . flyspell-mode)
     (prog-mode     . flyspell-prog-mode)
     (text-mode     . flyspell-mode))

    :config
    (setq ispell-program-name (executable-find "hunspell")
          ispell-dictionary   "en_US"))
#+END_SRC

**** gnus

I've bounced between using "real" email clients and gnus quite a few
times, though here we will attempt to make gnus behave like other
clients.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gnus
    :hook
    ((gnus-summary-prepared . gnus-summary-sort-by-most-recent-date)
     (gnus-group-mode       . gnus-group-sort-groups-by-alphabet))

    :bind
    (("<M-down>" . windmove-down)
     ("<M-up>"   . windmove-up))

    :config
    (defvar gnus-show-threads)
    (defvar gnus-sum-thread-tree-false-root)
    (defvar gnus-sum-thread-tree-indent)
    (defvar gnus-sum-thread-tree-leaf-with-other)
    (defvar gnus-sum-thread-tree-root)
    (defvar gnus-sum-thread-tree-single-leaf)
    (defvar gnus-sum-thread-tree-vertical)
    (defvar gnus-summary-thread-gathering-function)
    (defvar gnus-thread-hide-subtree)
    (defvar gnus-thread-sort-functions)

    (setq gnus-show-threads                      t
          gnus-sum-thread-tree-false-root        ""
          gnus-sum-thread-tree-indent            "  "
          gnus-sum-thread-tree-leaf-with-other   "├─> "
          gnus-sum-thread-tree-root              ""
          gnus-sum-thread-tree-single-leaf       "╰─> "
          gnus-sum-thread-tree-vertical          "│ "
          gnus-summary-line-format               "%U%R:%-15,15o  %-20,20A  %B%s\n"
          gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject
          gnus-thread-hide-subtree               t
          gnus-thread-sort-functions             '(gnus-thread-sort-by-date))

    (if (file-exists-p "~/.config/emacs/usr/gnus.el")
        (load-file     "~/.config/emacs/usr/gnus.el")))
#+END_SRC

**** helpful

This package provides an alternative to the built-in Emacs help that
provides much more contextual information.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package helpful)
#+END_SRC

**** highlight-indent-guides

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package highlight-indent-guides
    :demand t
    :hook (prog-mode . highlight-indent-guides-mode)
    :config (setq highlight-indent-guides-method 'character))
#+END_SRC

**** ibuffer

I'm not a fan of the default ibuffer behavior, if the total size of this
section does not make that clear. Here we will sort buffers, show human
readable sizes, and define a ton of filter groups.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ibuffer
    :commands (ibuffer-switch-to-saved-filter-groups)
    :hook
    ((ibuffer      . ibuffer-auto-mode)
     (ibuffer-mode . ibuffer-do-sort-by-alphabetic))

    :bind
    (("C-x C-b"         . ibuffer)
     ("<C-tab>"         . next-buffer)
     ("<C-iso-lefttab>" . previous-buffer))

    :init
    (add-hook 'ibuffer-auto-mode-hook
              (lambda()
                (ibuffer-switch-to-saved-filter-groups "default")))

    :config
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000)
        (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000)
        (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))

    (defvar ibuffer-show-empty-filter-groups)
    (defvar ibuffer-saved-filter-groups)

    (setq ibuffer-show-empty-filter-groups nil
          ibuffer-saved-filter-groups
          (quote (("default"
                   ("emacs"
                    (or (name . "^\\*Completions\\*$")
                        (name . "^\\*Customize\\*")
                        (name . "^\\*Disabled\s.*\\*$")
                        (name . "^\\*Help\\*$")
                        (name . "^\\*Messages\\*$")
                        (name . "^\\*scratch\\*.*$")))

                   ("apps"
                    (or (mode . dired-mode)
                        (mode . eshell-mode)))

                   ("dev"
                    (or (name . "^\\*clang")
                        (name . "^\\*gcc")
                        (name . "^\\*RTags")
                        (name . "^\\*rdm\\*")
                        (name . "magit")
                        (name . "COMMIT_EDITMSG")
                        (name . "^\\*Flycheck")
                        (name . "^\\*Flyspell")))

                   ("docs"
                    (or (name . "^\\*Man\s.*\s.*\\*$")
                        (name . "^\\*WoMan\s.*\s.*\\*$")
                        (mode . pdf-view-mode)))

                   ("irc"
                    (or (mode . circe-mode)
                        (mode . circe-channel-mode)
                        (mode . circe-query-mode)
                        (mode . circe-server-mode)))

                   ("logs"
                    (or (name . "^\\*EGLOT.*")
                        (name . "^\\*eldoc\\*$")
                        (name . "-Log\\*$")
                        (name . "\slog\\*$")))

                   ("mail"
                    (or (mode . message-mode)
                        (mode . bbdb-mode)
                        (mode . mail-mode)
                        (mode . gnus-group-mode)
                        (mode . gnus-summary-mode)
                        (mode . gnus-article-mode)
                        (name . "^\\.bbdb$")
                        (name . "^\\.newsrc-dribble")))

                   ("web"
                    (or (mode . eww-mode)
                        (name . "^\\*elfeed")))
                   )))

          ibuffer-formats '((mark
                             modified read-only " "
                             (name 35 35 :left :nil) " "
                             (size-h 9 -1 :right) " "
                             (mode 16 16 :left :elide) " "
                             filename-and-process))))
#+END_SRC

**** ivy

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ivy
    :commands (ivy-mode)
    :bind
    (("C-c C-r" . ivy-resume)
     ("<f6>"    . ivy-resume))

    :init (ivy-mode 1)

    :config
    (setq ivy-use-virtual-buffers      t
          enable-recursive-minibuffers t))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flyspell-correct-ivy
    :bind ("C-\\" . flyspell-correct-wrapper)
    :config (setq flyspell-correct-interface #'flyspell-correct-ivy))
#+END_SRC

**** magit

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package magit
    :demand t
    :bind ("C-c C-c" . with-editor-finish))
#+END_SRC

**** nov

This package provides a major mode for reading EPUB documents.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package nov
    :config (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+END_SRC

**** package-utils

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package package-utils
    :demand t)
#+END_SRC

**** rainbow-delimiters

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package rainbow-delimiters
    :demand t
    :hook ((markdown-mode prog-mode text-mode) . rainbow-delimiters-mode))
#+END_SRC

**** ranger

This package adds a minor mode that runs within ~dired~ that emulates
much of the features provided by the ~ranger~ terminal file browser.
Hardcore ~dired~ users may want to disable this.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ranger
    :commands (ranger-override-dired-mode)
    :init (ranger-override-dired-mode t))
#+END_SRC

**** scratch

I like opening multiple scratch buffers, so I added a function to allow
me to make a new numbered scratch buffer.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package scratch
    :init
    (defun scratch-new()
      "Open a new scratch buffer."
      (interactive)
      (switch-to-buffer (generate-new-buffer "*scratch*"))
      (lisp-mode)))
#+END_SRC

**** server

I feel that Emacs is missing some extensions for server-based functions
and added a warning when attempting to close Emacs. Also, if you want to
update your packages or kill Emacs without saving in a quicker fashion
you may appreciate the additional functions.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package server
    :after (package-utils)
    :commands (package-utils-upgrade-all server-start)
    :bind ("C-x C-c" . server-stop)
    :init
    (unless (and (fboundp 'server-running-p)
                 (server-running-p))
      (server-start))

    :config
    (defun server-kill()
      "Delete current Emacs server, then kill Emacs"
      (interactive)
      (if (y-or-n-p "Kill Emacs without saving? ")
          (kill-emacs)))

    (defun server-stop()
      "Prompt to save buffers, then kill Emacs."
      (interactive)
      (if (y-or-n-p "Quit Emacs? ")
          (save-buffers-kill-emacs)))

    (defun server-update()
      "Refresh package contents, then update all packages."
      (interactive)
      (package-initialize)
      (unless package-archive-contents
        (package-refresh-contents))
      (package-utils-upgrade-all)))
#+END_SRC

**** smartparens

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package smartparens
    :demand t
    :hook
    ((conf-mode eshell-mode markdown-mode org-mode prog-mode text-mode)
     . smartparens-mode)

    :config
    (setq sp-highlight-pair-overlay     nil
          sp-highlight-wrap-overlay     nil
          sp-highlight-wrap-tag-overlay nil))
#+END_SRC

**** undo-tree

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package undo-tree
    :demand t
    :commands (global-undo-tree-mode)
    :init (global-undo-tree-mode))
#+END_SRC

**** xclip

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package xclip
    :commands (xclip-mode)
    :init (xclip-mode 1))
#+END_SRC

**** yasnippet

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package yasnippet
    :commands (yas-minor-mode)
    :hook (prog-mode . yas-minor-mode))
#+END_SRC

*** Languages

**** Ansible

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ansible-vault)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company-ansible
    :after (company))
#+END_SRC

**** Apache

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package apache-mode)
#+END_SRC

**** C

#+BEGIN_SRC emacs-lisp :tangle config.el
  (add-hook 'c-mode-hook
            (lambda()
              (add-to-list 'auto-mode-alist '("\\.h\\'" . c-mode))
              (defvar c-basic-offset)
              (setq-local c-basic-offset   8)
              (setq-local indent-tabs-mode t)
              (setq-local tab-width        8)))
#+END_SRC

**** C++

#+BEGIN_SRC emacs-lisp :tangle config.el
  (add-hook 'c++-mode-hook
            (lambda()
              (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
              (defvar c-basic-offset)
              (setq-local c-basic-offset   4)
              (setq-local indent-tabs-mode t)
              (setq-local tab-width        4)))
#+END_SRC

**** Caddy

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package caddyfile-mode)
#+END_SRC

**** CMake

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package cmake-mode)
#+END_SRC

**** D

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package d-mode)
#+END_SRC

**** Docker

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package docker-compose-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package dockerfile-mode)
#+END_SRC

**** DotEnv

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package dotenv-mode)
#+END_SRC

**** GDScript

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gdscript-mode
    :config
    (setq gdscript-godot-executable "flatpak run org.godotengine.Godot"))
#+END_SRC

**** Git
These packages provide modes that make git-related files more readable.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gitattributes-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gitconfig-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gitignore-mode)
#+END_SRC

**** Go

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package go-mode
    :commands (gofmt)
    :mode ("\\.go\\'" . go-mode)
    :config
    (setq tab-width        4
          indent-tabs-mode 't))
#+END_SRC

**** Jinja2

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package jinja2-mode)
#+END_SRC

**** JSON

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package json-mode)
#+END_SRC

**** Lisp

#+BEGIN_SRC emacs-lisp :tangle config.el
  (add-hook 'lisp-mode-hook
            (lambda()
              (defvar c-basic-offset)
              (setq-local c-basic-offset   2)
              (setq-local indent-tabs-mode nil)
              (setq-local tab-width        2)))
#+END_SRC

**** Lua

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package lua-mode)
#+END_SRC

**** Markdown

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package markdown-mode)
#+END_SRC

**** Meson

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package meson-mode)
#+END_SRC

**** NGINX

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package nginx-mode)
#+END_SRC

**** Ninja

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ninja-mode)
#+END_SRC

**** Org

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package org
    :hook
    ((org-metadown  . windmove-down)
     (org-metaleft  . windmove-left)
     (org-metaright . windmove-right)
     (org-metaup    . windmove-up))

    :bind
    (:map org-mode-map
          ([remap backward-paragraph] . nil)
          ([remap forward-paragraph]  . nil)
          ("C-S-<down>" . nil)
          ("C-S-<up>"   . nil)
          ("S-<left>"   . nil)
          ("S-<right>"  . nil))

    :init
    (add-hook 'org-mode-hook
              (lambda ()
                (setq-local indent-tabs-mode nil)))

    :config
    (setq org-support-shift-select  'always
          org-src-fontify-natively  t
          org-src-tab-acts-natively t)

    (set-face-attribute 'org-block nil :background "#262626"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package org-bullets
    :commands (org-bullets-mode)
    :hook (org-mode . (lambda() (org-bullets-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package toc-org
    :after org
    :commands (toc-org-enable)
    :hook (org-mode . toc-org-enable))
#+END_SRC

**** PHP

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company-php
    :after (company php-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package php-mode)
#+END_SRC

**** Protobuf

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package protobuf-mode)
#+END_SRC

**** Python

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package python-mode)
#+END_SRC

**** Rust

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package cargo
    :commands (cargo-minor-mode)
    :hook (rust-mode . cargo-minor-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flycheck-rust
    :commands (flycheck-rust-setup)
    :hook (flycheck-mode . flycheck-rust-setup))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package rust-mode
    :commands (rust-format-buffer rust-mode)
    :mode ("\\.rs\\'" . rust-mode))
#+END_SRC

**** YAML

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package yaml-mode)
#+END_SRC
