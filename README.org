# -*- mode : org -*-
#+TITLE: Baemacs - A Literate GNU/Emacs Configuration
#+STARTUP: indent
#+LANGUAGE: en

Baemacs is yet another take on a literate GNU/Emacs configuration that intends
to remain close to the default behavior and appearance.  Baemacs is built with
use-package and org which is all contained within this singular file, which also
includes documentation and other such context.

Because this file is checked on init for changes, this single file becomes your
management tool for maintaining your Emacs config.  Whenever this file is newer
than a configuration file, your entire configuration will be tangled, compiled,
and loaded automatically.

#+HTML: <p align="center"><img src="img/baemacs.png" /></p>

The goals of Baemacs are fairly simplistic, mostly because I like Emacs and I
don't want to turn Emacs into some other editor.

1. Preserve (most) core GNU/Emacs functionality

   Unlike other configurations, there is no evil-mode support and we don't remap
   any (useful) default keybinds.  If you are comfortable with plain GNU/Emacs,
   you should feel empowered by Baemacs.  Vi/Vim and evil-mode users should most
   likely look at one of the many alternatives that provides or defaults to
   evil-mode.

2. Leverage use-package for predictability

   While a well-performing configuration doesn't have to rely on use-package, I
   find it far more obvious to manage and configure package rules and
   relationships using it.

   Though not specifically related to use-package, this configuration uses
   stable packages whenever possible so that there are no unexpected behaviors
   with a preference of elpa, then stable melpa, then melpa.

3. Fully document changes with context and reasoning (eventually)

   Having documentation, context of why something was added, and reasoning of
   whether it is a good/bad/subjective addition allows you as the user to better
   understand how each component ties together.

   Even better, you don't need to hunt any of this down, it's all in this file!

4. Performance is a concern, though avoid voodoo

   Emacs can initialize and run quickly without tricks, voodoo, or lies.  Most
   of the speed comes from properly configuring use-package to generate
   autoloads, and we don't do any background loading of packages.  Just about
   everything is loaded upfront on init, and it still takes about 0.5s to 1.0s
   depending on the performance of your device.  Anything that isn't loaded on
   init will be loaded on specific hooks or package relationships.

   There are two additional configuration changes that (hopefully) will have a
   positive effect on overall performance:

   - Tweaking [[#garbage-collection][Garbage Collection]]
   - Automatically [[#Bootstrap][Byte-compiling]] configuration files and packages

* Table of Contents :TOC_4:noexport:
- [[#usage][Usage]]
  - [[#install][Install]]
- [[#configuration-files][Configuration Files]]
  - [[#early-initel][early-init.el]]
    - [[#garbage-collection][Garbage Collection]]
      - [[#gc-cons-percentage][gc-cons-percentage]]
      - [[#gc-cons-threshold][gc-cons-threshold]]
    - [[#encoding][Encoding]]
    - [[#environment][Environment]]
    - [[#custom][Custom]]
    - [[#package-management][Package Management]]
      - [[#use-package][use-package]]
      - [[#no-littering][no-littering]]
      - [[#package-utils][package-utils]]
    - [[#disable-toolbars][Disable toolbars]]
    - [[#disable-splash-screen][Disable splash screen]]
  - [[#initel][init.el]]
    - [[#appearance][Appearance]]
      - [[#re-use-frames-and-windows][Re-use Frames and Windows]]
      - [[#font][Font]]
      - [[#theme][Theme]]
    - [[#editing][Editing]]
      - [[#clipboard][Clipboard]]
      - [[#scrolling][Scrolling]]
      - [[#line-numbers][Line Numbers]]
      - [[#modeline][Modeline]]
      - [[#parenthesis-matching][Parenthesis Matching]]
      - [[#whitespace][Whitespace]]
      - [[#word-wrap][Word Wrap]]
    - [[#input][Input]]
      - [[#keyboard][Keyboard]]
      - [[#mouse][Mouse]]
    - [[#bootstrap][Bootstrap]]
  - [[#configel][config.el]]
    - [[#packages][Packages]]
      - [[#async][async]]
      - [[#auto-compile][auto-compile]]
      - [[#circe][circe]]
      - [[#company][company]]
      - [[#counsel][counsel]]
      - [[#diff-hl][diff-hl]]
      - [[#dimmer-disabled][dimmer (Disabled)]]
      - [[#eglot][eglot]]
      - [[#eldoc][eldoc]]
      - [[#elfeed][elfeed]]
      - [[#eshell][eshell]]
      - [[#eww][eww]]
      - [[#flycheck][flycheck]]
      - [[#flyspell][flyspell]]
      - [[#gnus][gnus]]
      - [[#helpful][helpful]]
      - [[#highlight-indent-guides][highlight-indent-guides]]
      - [[#ibuffer][ibuffer]]
      - [[#ivy][ivy]]
      - [[#magit][magit]]
      - [[#nov][nov]]
      - [[#rainbow-delimiters][rainbow-delimiters]]
      - [[#ranger][ranger]]
      - [[#scratch][scratch]]
      - [[#server][server]]
      - [[#smartparens][smartparens]]
      - [[#swiper][swiper]]
      - [[#undo-tree][undo-tree]]
      - [[#xclip][xclip]]
      - [[#yasnippet][yasnippet]]
    - [[#languages][Languages]]
      - [[#apache][Apache]]
      - [[#bpftrace][bpftrace]]
      - [[#c][C]]
      - [[#c-1][C++]]
      - [[#caddy-disabled][Caddy (Disabled)]]
      - [[#cmake][CMake]]
      - [[#csv][CSV]]
      - [[#docker][Docker]]
      - [[#dotenv][DotEnv]]
      - [[#gdscript-disabled][GDScript (Disabled)]]
      - [[#git][Git]]
      - [[#go][Go]]
      - [[#hcl][HCL]]
      - [[#jinja2][Jinja2]]
      - [[#json][JSON]]
      - [[#julia][Julia]]
      - [[#lisp][Lisp]]
      - [[#markdown][Markdown]]
      - [[#meson][Meson]]
      - [[#nginx][NGINX]]
      - [[#ninja][Ninja]]
      - [[#org][Org]]
      - [[#php][PHP]]
      - [[#protobuf][Protobuf]]
      - [[#python][Python]]
      - [[#rust][Rust]]
      - [[#shell][Shell]]
      - [[#sed][Sed]]
      - [[#verilog][Verilog]]
      - [[#yaml][YAML]]
      - [[#zig][Zig]]

* Usage

This singular file is all that is needed to fully replicate this config.  While
you may simply download a copy of this file and use it, the steps below will
reference using git to retrieve and manage your copy of the config, which will
hopefully simplify incorporating your own changes.

** Install

By default, this configuration uses the XDG config path ~$HOME/.config~ which
will be ignored if any other configuration location is present.  This path may
or may not have been given a higher priority in recent releases.

#+BEGIN_SRC shell :eval no :tangle no
  $ git clone --depth 1 https://gitlab.com/jcmdln/baemacs.git ~/.config/emacs
#+END_SRC

Paste this rather unsightly block into your terminal to use Emacs from the
command line to tangle this file into the various configuration files, then
byte-compile the managed files, finally loading the ~init.el~.  This will
result in Emacs being fully setup and configured, and will never have to be run
manually again.

#+BEGIN_SRC shell :eval no :tangle no
  $ emacs --batch --eval="(progn (require 'org)
    (org-babel-tangle-file \"~/.config/emacs/README.org\")
    (byte-compile-file \"~/.config/emacs/early-init.el\")
    (byte-compile-file \"~/.config/emacs/init.el\")
    (byte-compile-file \"~/.config/emacs/config.el\")
    (load-file \"~/.config/emacs/early-init.el\")
    (load-file \"~/.config/emacs/init.el\"))"
#+END_SRC

* Configuration Files

To make the most effective use of the various startup files that Emacs will
check for, each file listed in this section will detail the changes they
contain.  The intention is to ensure that we don't force Emacs to load
everything during initialization, instead loading the following config file at
the end of initialization.

** early-init.el

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  ;;; early-init.el ---- Baemacs early initialization file
  ;;; Commentary:
  ;; Emacs will look for this specific file before initializing the GUI and
  ;; other such things.
  ;;; Code:
#+END_SRC

*** Garbage Collection

Emacs makes some considerations for older and more memory restricted systems in
terms of how the garbage collector is configured.  On modern 64-bit systems
these considerations may be far too conservative for users who run many elisp
programs such as gnus, elfeed, circe, etc.

As Emacs develops its concurrency, parallelism, and events primitives these
adjustments will need to be revisited.  Note that for memory constrained
environments you may want to disable the changes to the garbage collector made
in this section.

**** gc-cons-percentage

For the purposes of initialization, we'll increase ~gc-cons-percentage~ to
decrease garbage collection pauses.  The settings below mean that garbage
collection is deferred until reaching 80% of the total heap size.  After
initialization completes we lower this value to 20% of the total heap size to
prevent garbage collection passes from becoming too large to be handled
quickly.

At the time of writing, the default is 10% so we are effectively attempting to
halve the amount of garbage collection pauses we would experience as a result
of reaching the defined threshold of the total heap size.

Should you want to compare these changes against the default values, they are
preserved as shown below:

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (defvar baemacs/gc-cons-percentage-default gc-cons-percentage
    "Default value of gc-cons-percentage.")
  (defvar baemacs/gc-cons-percentage-init 0.8
    "Init value of gc-cons-percentage.")
  (defvar baemacs/gc-cons-percentage-tuned 0.2
    "Tuned value of gc-cons-percentage.")

  (setq gc-cons-percentage baemacs/gc-cons-percentage-init)

  (add-hook 'after-init-hook
            (lambda()
              (setq gc-cons-percentage baemacs/gc-cons-percentage-tuned)))
#+END_SRC

**** gc-cons-threshold

Now we will increase the ~gc-cons-threshold~, which refers to the total bytes
of storage for lisp objects that must be allocated to trigger subsequent
garbage collections.  On 32-bit systems this threshold is 400,000 objects,
while on 64-bit systems it is 800,000 objects.

Modifying this value is generally not recommended and considered an act of
performance voodoo, though the idea is that by specifying a larger threshold,
garbage collection will occur less often, meaning fewer GC pauses.  We'll set
this value to 10,000,000 globally, which ideally will reduce the total number
of GC pauses we experience without garbage collection taking too long when it
does occur.

The default value is also stored so you may evaluate this change as shown
below:

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (defvar baemacs/gc-cons-threshold-default gc-cons-threshold
    "Default value of gc-cons-threshold")
  (defvar baemacs/gc-cons-threshold-tuned (* 1000 1000 10)
    "Tuned value of gc-cons-threshold")

  (setq gc-cons-threshold baemacs/gc-cons-threshold-tuned)
#+END_SRC

*** Encoding

Another thing we want to handle very early is attempting to enforce the use of
UTF-8 encoding.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (defvar prefer-coding-system)
  (defvar set-default-coding-systems)
  (defvar set-language-environment)
  (defvar set-locale-environment)

  (setq prefer-coding-system       'utf-8
        set-default-coding-systems 'utf-8
        set-language-environment   "UTF-8"
        set-locale-environment     "en_US.UTF-8")
#+END_SRC

*** Environment

Emacs will inherit your system's current environment, though we may adjust some
key variables for quality of life.

- Set Emacs as our default ~EDITOR~ when in Emacs
- Set ~PAGER~ to an Emacs built-in, which doesn't require ansi-term
- Unset ~PROMPT_COMMAND~, which causes issues with ssh connections
- Attempt to get/set certain variables, in case they differ

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setenv "EDITOR"         "emacsclient")
  (setenv "GIT_EDITOR"     "emacsclient")
  (setenv "MANPATH"        (getenv "MANPATH"))
  (setenv "PAGER"          "cat")
  (setenv "PATH"           (getenv "PATH"))
  (setenv "PROMPT_COMMAND" "")
  (setenv "SHELL"          (getenv "SHELL"))
  (setenv "TERM"           (getenv "TERM"))
#+END_SRC

*** Custom

Rather than Emacs customization being appended to the end of the configuration
file, in our case ~init.el~, we may specify the location of ~custom-file~ early
on to keep our configuration directory relatively clean.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq custom-file (concat user-emacs-directory "custom.el"))
#+END_SRC

*** Package Management

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (require 'package)
#+END_SRC

Here we're defining where to put packages, where we should get packages from,
and the priority we should retrieve packages if a package with the same name
exists on multiple sources.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq package-user-dir (concat user-emacs-directory "pkg/")

        package-archives
        '(("elpa"         . "https://elpa.gnu.org/packages/")
          ("melpa-stable" . "https://stable.melpa.org/packages/")
          ("melpa"        . "https://melpa.org/packages/"))

        package-archive-priorities
        '(("elpa"         . 3)
          ("melpa-stable" . 2)
          ("melpa"        . 1))

        package-pinned-packages
        '((use-package . "melpa")
          (hcl-mode    . "melpa")))
#+END_SRC

With the above changes made, we may now initialize the package module:

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (package-initialize)
#+END_SRC

**** use-package

The first package we'll ensure exists is use-package, which the rest of this
file relies on for handling per-package configuration.  In newer versions of
Emacs use-package is now a built-in, but we should check to be nice to older
versions:

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package)
    (require 'bind-key))
#+END_SRC

Some decent use-package tweaks are to defer loading a package unless demanded,
ensure a package exists or can be retrieved before loading its configuration,
and check that use-package is installed and active before attempting to
initialize:

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq use-package-always-ensure     't
        use-package-check-before-init 't)
#+END_SRC

**** no-littering

The second package will keep our Emacs configuration directory nice and tidy by
adjusting the locations of configuration files.  It uses a unixy format, which
is a nice change.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (use-package no-littering
    :commands (no-littering-expand-var-file-name)
    :init
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") 't))))
#+END_SRC

**** package-utils

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package package-utils
    :commands (baemacs-update)
    :init
    (defun baemacs-update()
      "Refresh package contents, then update all packages."
      (interactive)
      (unless package-archive-contents
        (package-refresh-contents))
      (package-utils-upgrade-all)))
#+END_SRC

*** Disable toolbars

I don't find the toolbars to be useful comparatively to the amount of visual
space they consume.  The following will disable the various toolbars when their
functions are bound, which prevents them from ever being initialized:

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (when (fboundp 'menu-bar-mode)   (menu-bar-mode   -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (when (fboundp 'tool-bar-mode)   (tool-bar-mode   -1))
#+END_SRC

*** Disable splash screen

After initialization completes, we'll end up with some clutter that is not very
helpful for long-time Emacs users.

- Remove the default scratch buffer message
- Disable the splash screen
- Disable the startup buffer menu

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq initial-scratch-message     ""
        inhibit-splash-screen       't
        inhibit-startup-buffer-menu 't)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (provide 'early-init)
  ;;; early-init.el ends here
#+END_SRC

** init.el

Emacs will look for this specific file once it reaches the init phase.  Here we
will make modifications to things that ship with Emacs and should be changed as
early as possible.

#+BEGIN_SRC emacs-lisp :tangle init.el
  ;;; init.el ---- Baemacs initialization file
  ;;; Commentary:
  ;; Emacs will look for this specific file once it reaches the
  ;; initialization phase.  Here we will make modifications to things that
  ;; ship with Emacs and should be changed early.
  ;;; Code:
#+END_SRC

*** Appearance

In terms of appearance, I prefer to have as little wasted space and visual
clutter as possible.  I make no attempt to completely restyle Emacs, preferring
instead to make slight modifications.

**** Re-use Frames and Windows

One big annoyance is Emacs arbitrary splitting my window to show a newly
created buffer.  This is especially annoying when I run a command myself such
as ~M-x man~ which causes arbitrary splits.

Here we will enforce always re-using the currently selected frame when a new
buffer is opened or focused.  This works in most cases, though as shown below
certain things like 'man' will not respect our choices and require specific
adjustment.  Some things like 'gnus' should still make splits as they want, so
we won't look for every possible edge condition to normalize this behavior.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-to-list 'display-buffer-alist '("*Help*" display-buffer-same-window))
  (add-to-list 'display-buffer-alist '("*Man*" display-buffer-same-window))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar pop-up-frames)
  (defvar pop-up-windows)
  (defvar reusable-frames)
  (defvar Man-notify-method)

  (setq pop-up-frames     nil
        pop-up-windows    nil
        reusable-frames   't
        Man-notify-method 'pushy)
#+END_SRC

**** Font

This probably isn't needed, but we'll set the default font to the monospace
font defined on the system.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (set-face-attribute :family "Monospace")
#+END_SRC

**** Theme

Rather than include yet another theme, we’ll use the tango-dark theme.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (load-theme 'tango-dark 't)
#+END_SRC

*** Editing

There are some general-purpose changes to make for editing files, which ideally
if I ever get around to incorporating ~site-start.el~ will allow loading a slim,
nimble instance of Emacs when needed.  For now I'll leave these changes here.

**** Clipboard

This part is a bit unorganized though reduces clutter by inhibiting buffers and
adjusting how the clipboard works in Emacs.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq save-interprogram-paste-before-kill 't
        select-enable-primary               nil)
#+END_SRC

**** Scrolling

- Scroll line-by-line
- Preserve the cursor position when scrolling
- No scroll margins
- Don't scroll past the end of a buffer

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq auto-window-vscroll             nil
        scroll-conservatively           101
        scroll-margin                   0
        scroll-preserve-screen-position 1
        scroll-step                     1
        scroll-up-aggressively          0.0
        scroll-down-aggressively        0.0)
#+END_SRC

**** Line Numbers

Display line numbers in most types of modes where it makes sense.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook
            (lambda()
              (add-hook 'conf-mode-hook 'display-line-numbers-mode)
              (add-hook 'prog-mode-hook 'display-line-numbers-mode)
              (add-hook 'org-mode-hook  'display-line-numbers-mode)
              (add-hook 'text-mode-hook 'display-line-numbers-mode)))
#+END_SRC

**** Modeline

- Show column numbers
- Ensure ~\n~ always precedes EOF
- When ~show-paren-mode~ is enabled, delay showing match for 330ms
- Disable the ~visual-bell~

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar show-paren-delay)

  (setq column-number-mode    't
        require-final-newline 't
        show-paren-delay      0.33
        visible-bell          nil)
#+END_SRC

**** Parenthesis Matching

Highlight matching parenthesis, always.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook (lambda() (show-paren-mode 't)))
#+END_SRC

**** Whitespace

Before saving, remove any trailing whitespace characters.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

**** Word Wrap

When Visual Line mode is enabled, ‘word-wrap’ is turned on in this buffer, and
simple editing commands are redefined to act on visual lines, not logical
lines.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook (lambda() (global-visual-line-mode 't)))
#+END_SRC

*** Input

I do make some minor changes to input methods, though I intend to remain as
faithful to "the Emacs way" as I can.

**** Keyboard

In terms of keyboard input, I only make slight adjustments though their
usefulness is highly subjective.

****** Keybinds

From my time of using tmux + vim I had grown to prefer some custom keybinds I
made for handling splits or navigating through panes. Here I've attempted to
recreated the subjective ease of navigation I prefer:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-set-key (kbd "M--")
                  (lambda()
                    (interactive)
                    (split-window-vertically)
                    (other-window 1 nil)
                    (switch-to-next-buffer)))

  (global-set-key (kbd "M-=")
                  (lambda()
                    (interactive)
                    (split-window-horizontally)
                    (other-window 1 nil)
                    (switch-to-next-buffer)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (global-set-key (kbd "C-c c")     'comment-or-uncomment-region)
  (global-set-key (kbd "<M-down>")  'windmove-down)
  (global-set-key (kbd "<M-left>")  'windmove-left)
  (global-set-key (kbd "<M-right>") 'windmove-right)
  (global-set-key (kbd "<M-up>")    'windmove-up)

  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

**** Mouse

In terms of the mouse, I really only adjust scrolling behavior and add xterm
support:

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar mouse-wheel-follow-mouse)
  (defvar mouse-wheel-progressive-speed)
  (defvar mouse-wheel-scroll-amount)

  (setq mouse-wheel-follow-mouse      't
        mouse-wheel-progressive-speed nil
        mouse-wheel-scroll-amount     '(1 ((shift) . 1))
        mouse-yank-at-point           't)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'after-init-hook
            (lambda()
              (xterm-mouse-mode 1)))

  (global-set-key (kbd "<mouse-4>")
                  (lambda()
                    (interactive)
                    (scroll-down-line 3)))

  (global-set-key (kbd "<mouse-5>")
                  (lambda()
                    (interactive)
                    (scroll-up-line 3)))
#+END_SRC

*** Bootstrap

Something we can do to slightly improve the total duration needed for Emacs to
complete its initialization phase is byte-compile the configuration files we
create.  If performed conditionally, we only have to pay the cost of
byte-compiling when we make a change to this configuration file for the entire
configuration to be rebuilt.

At the end of initialization, ensure that ~README.org~ is not newer than
~config.el~, otherwise rebuild our configuration files and byte-compile them.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun baemacs-reconfig()
    "Tangle, build, and load configuration."
    (interactive)
    (require 'org)
    (org-babel-tangle-file (concat user-emacs-directory "README.org"))

    (byte-compile-file (concat user-emacs-directory "early-init.el"))
    (byte-compile-file (concat user-emacs-directory "init.el"))
    (byte-compile-file (concat user-emacs-directory "config.el"))

    (load (concat user-emacs-directory "early-init.el"))
    (load (concat user-emacs-directory "init.el")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (if (file-newer-than-file-p (concat user-emacs-directory "README.org")
                              (concat user-emacs-directory "config.el"))
      (baemacs-reconfig)
    (load (concat user-emacs-directory "config.el")))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle init.el
  (provide 'init)
  ;;; init.el ends here
#+END_SRC

** config.el

This is a non-standard file that is referenced at the end of ~init.el~ which
contains our extra package and language definitions. Before we add anything to
this file, first we'll add the file header:

#+BEGIN_SRC emacs-lisp :tangle config.el
  ;;; config.el ---- Baemacs configuration file
  ;;; Commentary:
  ;; This is a non-standard file that is referenced at the end of 'init.el'
  ;; which contains our extra package and language definitions.
  ;;; Code:
#+END_SRC

*** Packages

**** async

Simplify calling asynchronous functions and processes.  See the documentation
for ~async-start~ and ~async-start-process~ for more information.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package async
    :config
    (async-bytecomp-package-mode '(all)))
#+END_SRC

**** auto-compile

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package auto-compile
    :commands (auto-compile-on-load-mode auto-compile-on-save-mode)
    :config
    (auto-compile-on-load-mode)
    (auto-compile-on-save-mode))
#+END_SRC

**** circe

This package adds _another_ IRC client, which is my preferred client even over
irssi, weechat, or other clients I've used in the past.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package circe
    :defer 't
    :commands (enable-lui-logging-globally lui-set-prompt)
    :config
    (defvar circe-default-part-message)
    (defvar circe-default-quit-message)
    (defvar circe-format-server-topic)
    (defvar circe-reduce-lurker-spam)
    (defvar circe-use-cycle-completion)
    (defvar lui-fill-type)
    (defvar lui-flyspell-alist)
    (defvar lui-flyspell-p)
    (defvar lui-time-stamp-format)
    (defvar lui-time-stamp-position)

    (setq circe-default-part-message ""
          circe-default-quit-message ""
          circe-format-server-topic  "*** Topic: {userhost}: {topic-diff}"
          circe-reduce-lurker-spam   't
          circe-use-cycle-completion 't

          lui-fill-type              nil
          lui-flyspell-alist         '((".*" "american"))
          lui-flyspell-p             't
          lui-time-stamp-format      "%H:%M:%S"
          lui-time-stamp-position    'left-margin)

    (add-hook 'circe-server-mode-hook (lambda() (require 'circe-chanop)))
    (add-hook 'circe-chat-mode-hook
              (lambda()
                (lui-set-prompt
                 (concat (propertize
                          (concat (buffer-name) ":")
                          'face 'circe-prompt-face)
                         " "))))

    (add-hook 'lui-mode-hook
              (lambda()
                (setq fringes-outside-margins 't
                      left-margin-width       9
                      word-wrap               't
                      wrap-prefix             "")))

    (enable-circe-color-nicks)

    (if (file-exists-p (concat user-emacs-directory "usr/circe.el"))
        (load-file     (concat user-emacs-directory "usr/circe.el"))))
#+END_SRC

**** company

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company
    :config
    (defvar company-begin-commands)
    (defvar company-echo-delay)
    (defvar company-idle-delay)
    (defvar company-tooltip-limit)

    (setq company-begin-commands '(self-insert-command)
          company-idle-delay     0.3
          company-echo-delay     0
          company-tooltip-limit  20)

    :hook ((prog-mode . company-mode)
           (text-mode . company-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company-c-headers
    :after (company)
    :config (add-to-list 'company-backends 'company-c-headers))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company-emoji
    :if window-system
    :after (company))
#+END_SRC

**** counsel

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package counsel
    :bind (("<f1> f"  . counsel-describe-function)
           ("<f1> l"  . counsel-find-library)
           ("<f1> v"  . counsel-describe-variable)
           ("<f2> i"  . counsel-info-lookup-symbol)
           ("<f2> u"  . counsel-unicode-char)
           ("C-s"     . counsel-grep-or-swiper)
           ("C-c g"   . counsel-git)
           ("C-c j"   . counsel-git-grep)
           ("C-c l"   . counsel-ag)
           ("C-r"     . counsel-minibuffer-history)
           ("C-x C-f" . counsel-find-file)
           ("C-x l"   . counsel-locate)
           ("M-x"     . counsel-M-x)))
#+END_SRC

**** diff-hl

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package diff-hl
    :demand 't
    :commands (diff-hl-mode diff-hl-margin-mode)
    :hook ((conf-mode prog-mode text-mode) . diff-hl-mode)
    :config
    (when (eq window-system nil)
      (add-hook 'after-init-hook
                (lambda()
                  (add-hook 'conf-mode-hook 'diff-hl-margin-mode)
                  (add-hook 'org-mode-hook  'diff-hl-margin-mode)
                  (add-hook 'prog-mode-hook 'diff-hl-margin-mode)
                  (add-hook 'text-mode-hook 'diff-hl-margin-mode)))))
#+END_SRC

**** dimmer (Disabled)

This package provides a minor mode which dims inactive buffers, namely the
buffers the cursor is not currently active in. It can be helpful for those who
use many buffers.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package dimmer
    :disabled
    :commands (dimmer-mode)
    :hook (after-init . dimmer-mode))
#+END_SRC

**** eglot

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eglot
    :commands (eglot-ensure)
    :config
    (defvar eglot-auto-display-help-buffer)
    (defvar eglot-put-doc-in-help-buffer)

    (setq eglot-auto-display-help-buffer nil
          eglot-put-doc-in-help-buffer   nil)

    (add-to-list 'eglot-server-programs '(c-mode . ("clangd")))
    (add-to-list 'eglot-server-programs '(c++-mode . ("clangd")))

    :hook (((c-mode c++-mode go-mode python-mode rust-mode) . 'eglot-ensure)
           (eglot-managed-mode . (lambda()
                                   (add-hook 'before-save-hook
                                             'eglot-format-buffer
                                             nil 'local)))))
#+END_SRC

**** eldoc

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eldoc
    :commands (global-eldoc-mode)
    :config (setq eldoc-echo-area-use-multiline-p nil))
#+END_SRC

**** elfeed

This package provides an extensible web feed reader, supporting both RSS and
Atom.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package elfeed
    :bind ("C-x w" . elfeed)
    :config
    (defvar elfeed-search-filter)

    (setq elfeed-search-filter "@1-week-ago +unread "
          url-queue-timeout    10)

    (if (file-exists-p (concat user-emacs-directory "usr/elfeed.el"))
        (load-file     (concat user-emacs-directory "usr/elfeed.el"))))
#+END_SRC

**** eshell

The default configuration of eshell is... well, bad. The ordinary user who
opens it once and considers it to be a bad tool is missing out of the full
potential eshell provides. I've spent a _lot_ of time making eshell behave and
look like typical unix shells, so maybe try it for yourself.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eshell
    :commands (baemacs/eshell/clear
               baemacs/eshell/prompt-function
               eshell
               eshell-new
               eshell-truncate-buffer
               eshell/basename
               eshell/pwd)

    :config
    (defun baemacs/eshell/clear()
      "Clear the current eshell buffer by truncating the contents."
      (interactive)
      (defvar eshell-buffer-maximum-lines)
      (setq-local eshell-buffer-maximum-lines 0)
      (eshell-truncate-buffer))

    (defun baemacs/eshell/prompt-function()
      "Custom eshell prompt."
      (interactive)
      (lambda ()
        (concat "[" (user-login-name) "@"
                (car (split-string (system-name) "\\.")) " "
                (if (string= (eshell/pwd) (getenv "HOME"))
                    "~" (eshell/basename (eshell/pwd))) "]"
                (if (= (user-uid) 0) "# " "$ "))))

    (defvar eshell-banner-message)
    (defvar eshell-cmpl-cycle-completions)
    (defvar eshell-error-if-no-glob)
    (defvar eshell-hist-ignoredups)
    (defvar eshell-history-size)
    (defvar eshell-prompt-function)
    (defvar eshell-prompt-regexp)
    (defvar eshell-save-history-on-exit)
    (defvar eshell-scroll-show-maximum-output)
    (defvar eshell-scroll-to-bottom-on-input)
    (defvar eshell-scroll-to-bottom-on-output)
    (defvar eshell-visual-commands)

    (setq eshell-banner-message             ""
          eshell-cmpl-cycle-completions     nil
          eshell-error-if-no-glob           't
          eshell-hist-ignoredups            't
          eshell-history-size               4096
          eshell-prefer-lisp-functions      't
          eshell-prompt-function            (baemacs/eshell/prompt-function)
          eshell-prompt-regexp              "^[^#$\n]*[#$] "
          eshell-save-history-on-exit       't
          eshell-scroll-to-bottom-on-input  nil
          eshell-scroll-to-bottom-on-output nil
          eshell-scroll-show-maximum-output nil)

    :hook (eshell-mode . (lambda()
                           (defalias 'eshell/clear 'baemacs/eshell/clear)))

    :init
    (defun eshell-new()
      "Open a new instance of eshell."
      (interactive)
      (eshell 'N)))
#+END_SRC

**** eww

I like eww, but it was missing a few things for me to use it as my primary
browser for non-interactive sites. Here we will ensure that eww is our primary
browser when visiting links, and that images are blocked by default. Should you
have multiple eww buffers open and want to toggle displaying images in a
specific buffer, you may now do so.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eww
    :commands (eww eww-mode eww-reload eww-toggle-images eww-new)

    :config
    (when window-system
      (setq shr-blocked-images "")

      (defun eww-toggle-images()
        "Toggle blocking images in eww."
        (interactive)
        (if (bound-and-true-p shr-blocked-images)
            (setq-local shr-blocked-images nil)
          (setq-local shr-blocked-images ""))
        (eww-reload)))

    :init
    (setq browse-url-browser-function 'eww-browse-url)

    (defun eww-new()
      "Open a new instance of eww."
      (interactive)
      (let ((url (read-from-minibuffer "Enter URL or keywords: ")))
        (switch-to-buffer (generate-new-buffer "*eww*"))
        (eww-mode)
        (eww url))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package eww-lnum
    :bind (:map eww-mode-map
                ("f" . eww-lnum-follow)
                ("F" . eww-lnum-universal))
    :commands (eww-lnum-follow eww-lnum-universal))
#+END_SRC

**** flycheck

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flycheck
    :hook (prog-mode . flycheck-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flycheck-inline
    :commands (turn-on-flycheck-inline)
    :hook (flycheck-mode . (lambda() (turn-on-flycheck-inline))))
#+END_SRC

**** flyspell

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flyspell
    :config
    (setq ispell-program-name (executable-find "hunspell")
          ispell-dictionary   "en_US")

    :hook (((conf-mode markdown-mode text-mode) . flyspell-mode)
           (prog-mode . flyspell-prog-mode)))
#+END_SRC

**** gnus

I've bounced between using "real" email clients and gnus quite a few times,
though here we will attempt to make gnus behave like other clients.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gnus
    :bind (("<M-down>" . windmove-down)
           ("<M-up>"   . windmove-up))

    :config
    (defvar gnus-show-threads)
    (defvar gnus-sum-thread-tree-false-root)
    (defvar gnus-sum-thread-tree-indent)
    (defvar gnus-sum-thread-tree-leaf-with-other)
    (defvar gnus-sum-thread-tree-root)
    (defvar gnus-sum-thread-tree-single-leaf)
    (defvar gnus-sum-thread-tree-vertical)
    (defvar gnus-summary-thread-gathering-function)
    (defvar gnus-thread-hide-subtree)
    (defvar gnus-thread-sort-functions)

    (setq gnus-show-threads                      't
          gnus-sum-thread-tree-false-root        ""
          gnus-sum-thread-tree-indent            "  "
          gnus-sum-thread-tree-leaf-with-other   "├─> "
          gnus-sum-thread-tree-root              ""
          gnus-sum-thread-tree-single-leaf       "╰─> "
          gnus-sum-thread-tree-vertical          "│ "
          gnus-summary-line-format               "%U%R:%-15,15o  %-20,20A  %B%s\n"
          gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject
          gnus-thread-hide-subtree               't
          gnus-thread-sort-functions             '(gnus-thread-sort-by-date))

    (if (file-exists-p (concat user-emacs-directory "usr/gnus.el"))
        (load-file     (concat user-emacs-directory "usr/gnus.el")))

    :hook ((gnus-summary-prepared . gnus-summary-sort-by-most-recent-date)
           (gnus-group-mode       . gnus-group-sort-groups-by-alphabet)))
#+END_SRC

**** helpful

This package provides an alternative to the built-in Emacs help that provides
much more contextual information.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package helpful
    :bind (("C-h C" . #'helpful-command)
           ("C-h F" . #'helpful-function)
           ("C-h f" . #'helpful-callable)
           ("C-h k" . #'helpful-key)
           ("C-h v" . #'helpful-variable)))
#+END_SRC

**** highlight-indent-guides

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package highlight-indent-guides
    :config (setq highlight-indent-guides-method 'character)
    :hook (prog-mode . highlight-indent-guides-mode))
#+END_SRC

**** ibuffer

I'm not a fan of the default ibuffer behavior, if the total size of this
section does not make that clear. Here we will sort buffers, show human
readable sizes, and define a ton of filter groups.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ibuffer
    :bind (("C-x C-b"         . ibuffer)
           ("<C-tab>"         . next-buffer)
           ("<C-iso-lefttab>" . previous-buffer))

    :commands (ibuffer-switch-to-saved-filter-groups)

    :config
    (add-hook 'ibuffer-auto-mode-hook
              (lambda()
                (ibuffer-switch-to-saved-filter-groups "default")))

    (define-ibuffer-column size-h
      (:name "Size" :inline 't)
      (cond ((> (buffer-size) (* 1000 1000 1000))
             (format "%7.1fG" (/ (buffer-size) 1000000000.0)))
            ((> (buffer-size) (* 1000 1000))
             (format "%7.1fM" (/ (buffer-size) 1000000.0)))
            ((> (buffer-size) 1000)
             (format "%7.1fK" (/ (buffer-size) 1000.0)))
            ('t (format "%8d" (buffer-size)))))

    (defvar ibuffer-show-empty-filter-groups)
    (defvar ibuffer-saved-filter-groups)

    (setq ibuffer-show-empty-filter-groups nil
          ibuffer-saved-filter-groups
          (quote (("default"
                   ("emacs"
                    (or (name . "^\\*Completions\\*$")
                        (name . "^\\*Customize\\*")
                        (name . "^\\*Disabled\s.*\\*$")
                        (name . "^\\*Help\\*$")
                        (name . "^\\*Messages\\*$")
                        (name . "^\\*scratch\\*.*$")))

                   ("apps"
                    (or (mode . dired-mode)
                        (mode . eshell-mode)))

                   ("dev"
                    (or (name . "^\\*clang")
                        (name . "^\\*gcc")
                        (name . "^\\*RTags")
                        (name . "^\\*rdm\\*")
                        (name . "magit")
                        (name . "COMMIT_EDITMSG")
                        (name . "^\\*Flycheck")
                        (name . "^\\*Flyspell")))

                   ("docs"
                    (or (name . "^\\*Man\s.*\s.*\\*$")
                        (name . "^\\*WoMan\s.*\s.*\\*$")
                        (mode . pdf-view-mode)))

                   ("irc"
                    (or (mode . circe-mode)
                        (mode . circe-channel-mode)
                        (mode . circe-query-mode)
                        (mode . circe-server-mode)))

                   ("logs"
                    (or (name . "^\\*EGLOT.*")
                        (name . "^\\*eldoc\\*$")
                        (name . "-Log\\*$")
                        (name . "\slog\\*$")))

                   ("mail"
                    (or (mode . message-mode)
                        (mode . bbdb-mode)
                        (mode . mail-mode)
                        (mode . gnus-group-mode)
                        (mode . gnus-summary-mode)
                        (mode . gnus-article-mode)
                        (name . "^\\.bbdb$")
                        (name . "^\\.newsrc-dribble")))

                   ("web"
                    (or (mode . eww-mode)
                        (name . "^\\*elfeed")))
                   )))

          ibuffer-formats '((mark
                             modified read-only " "
                             (name 35 35 :left :nil) " "
                             (size-h 9 -1 :right) " "
                             (mode 16 16 :left :elide) " "
                             filename-and-process)))

    :hook ((ibuffer      . ibuffer-auto-mode)
           (ibuffer-mode . ibuffer-do-sort-by-alphabetic)))
#+END_SRC

**** ivy

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ivy
    :commands (ivy-mode)
    :hook (after-init . (lambda() (ivy-mode 1)))
    :bind (("C-c C-r" . ivy-resume)
           ("<f6>"    . ivy-resume))

    :config
    (setq ivy-use-virtual-buffers      't
          enable-recursive-minibuffers 't))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ivy-rich
    :commands (ivy-rich-mode)
    :hook (ivy-mode . (lambda() (ivy-rich-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flyspell-correct-ivy
    :after (flyspell ivy)
    :bind ("C-\\" . flyspell-correct-wrapper)
    :config (setq flyspell-correct-interface #'flyspell-correct-ivy))
#+END_SRC

**** magit

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package magit
    :bind ("C-c C-c" . with-editor-finish)
    :demand 't)
#+END_SRC

**** nov

This package provides a major mode for reading EPUB documents.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode))
#+END_SRC

**** rainbow-delimiters

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package rainbow-delimiters
    :hook ((conf-mode prog-mode text-mode) . rainbow-delimiters-mode))
#+END_SRC

**** ranger

This package adds a minor mode that runs within ~dired~ that emulates much of
the features provided by the ~ranger~ terminal file browser.  Hardcore ~dired~
users may want to disable this.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ranger
    :commands (ranger-override-dired-mode)
    :init (ranger-override-dired-mode 't))
#+END_SRC

**** scratch

I like opening multiple scratch buffers, so I added a function to allow me to
make a new numbered scratch buffer.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package scratch
    :commands (scratch-new)
    :init
    (defun scratch-new()
      "Open a new scratch buffer."
      (interactive)
      (switch-to-buffer (generate-new-buffer "*scratch*"))
      (lisp-mode)))
#+END_SRC

**** server

I feel that Emacs is missing some extensions for server-based functions and
added a warning when attempting to close Emacs. Also, if you want to update
your packages or kill Emacs without saving in a quicker fashion you may
appreciate the additional functions.

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package server
    :bind ("C-x C-c" . baemacs-server-stop)
    :commands (package-utils-upgrade-all server-start)
    :config
    (unless (and (fboundp 'server-running-p) (server-running-p)) (server-start))
    :demand 't
    :init
    (defun baemacs-server-kill()
      "Delete current Emacs server, then kill Emacs"
      (interactive)
      (if (y-or-n-p "Kill Emacs without saving? ")
          (kill-emacs)))

    (defun baemacs-server-stop()
      "Prompt to save buffers, then kill Emacs."
      (interactive)
      (if (y-or-n-p "Quit Emacs? ")
          (save-buffers-kill-emacs))))
#+END_SRC

**** smartparens

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package smartparens
    :config
    (setq sp-highlight-pair-overlay     nil
          sp-highlight-wrap-overlay     nil
          sp-highlight-wrap-tag-overlay nil)

    :hook ((eshell-mode org-mode prog-mode text-mode)
           . turn-on-smartparens-mode))
#+END_SRC

**** swiper

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package swiper
    :after (counsel ivy))
#+END_SRC

**** undo-tree

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package undo-tree
    :commands (global-undo-tree-mode)
    :init (global-undo-tree-mode))
#+END_SRC

**** xclip

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package xclip
    :commands (xclip-mode)
    :init
    (if (or (executable-find "xclip")
            (executable-find "xclipboard"))
        (xclip-mode 1)
      nil))
#+END_SRC

**** yasnippet

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package yasnippet
    :after (eglot)
    :commands (yas-minor-mode)
    :hook (prog-mode . yas-minor-mode))
#+END_SRC

*** Languages

**** Apache

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package apache-mode
    :disabled)
#+END_SRC

**** bpftrace

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package bpftrace-mode
    :mode ("\\.bt\\'" . bpftrace-mode))
#+END_SRC

**** C

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package cc-mode
    :init
    (add-hook 'c-mode-hook
              (lambda()
                (add-to-list 'auto-mode-alist '("\\.h\\'" . c-mode))

                (setq-local c-basic-offset   8
                            c-default-style  "linux"
                            indent-tabs-mode 't
                            tab-width        8)))

    :mode ("\\.c\\'" . c-mode))
#+END_SRC

**** C++

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package cc-mode
    :init
    (add-hook 'c++-mode-hook
              (lambda()
                (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
                (add-to-list 'auto-mode-alist '("\\.hpp\\'" . c++-mode))

                (setq-local c-basic-offset   4
                            c-default-style  "ellemtel"
                            indent-tabs-mode 't'
                            tab-width        4)))

    :mode (("\\.cpp\\'" . c++-mode)
           ("\\.cxx\\'" . c++-mode)))
#+END_SRC

**** Caddy (Disabled)

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package caddyfile-mode
    :disabled)
#+END_SRC

**** CMake

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package cmake-mode
    :defer 't)
#+END_SRC

**** CSV

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package csv-mode
    :mode ("\\.csv\\'" . csv-mode))
#+END_SRC

**** Docker

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package docker-compose-mode
    :mode (("\\docker-compose.yml\\'" . docker-compose-mode)
           ("\\podman-compose.yml\\'" . docker-compose-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package dockerfile-mode
    :mode (("\\Containerfile\\'" . dockerfile-mode)
           ("\\Dockerfile\\'"    . dockerfile-mode)))
#+END_SRC

**** DotEnv

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package dotenv-mode
    :defer 't)
#+END_SRC

**** GDScript (Disabled)

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gdscript-mode
    :disabled)
#+END_SRC

**** Git

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gitattributes-mode
    :mode ("\\.gitattributes\\'" . gitattributes-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gitconfig-mode
    :mode (("\\.gitconfig\\'"  . gitconfig-mode)
           ("\\.gitmodules\\'" . gitignore-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package gitignore-mode
    :mode (("\\.gitignore\\'"    . gitignore-mode)
           ("\\.dockerignore\\'" . gitignore-mode)))
#+END_SRC

**** Go

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package go-mode
    :init
    (add-hook 'go-mode-hook
              (lambda()
                (setq-local c-basic-offset   4
                            indent-tabs-mode nil
                            tab-width        4)))

    :mode ("\\.go\\'" . go-mode))
#+END_SRC

**** HCL

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package hcl-mode
    :init
    (add-hook 'hcl-mode-hook
              (lambda()
                (add-hook 'before-save-hook
                          (lambda() (untabify (point-min) (point-max)))
                          nil 'local)

                (setq-local c-basic-offset   4
                            hcl-indent-level 4
                            indent-tabs-mode nil
                            tab-width        4)))

    :mode (("\\.hcl\\'" . hcl-mode)))
#+END_SRC

**** Jinja2

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package jinja2-mode
    :mode ("\\.j2\\'" . jinja2-mode))
#+END_SRC

**** JSON

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package json-mode
    :init
    (add-hook 'json-mode-hook
              (lambda()
                (add-hook 'before-save-hook
                          (lambda() (untabify (point-min) (point-max)))
                          nil 'local)

                (setq-local c-basic-offset         2
                            indent-tabs-mode       nil
                            json-mode-indent-level 2
                            tab-width              2)))

    :mode ("\\.json\\'" . json-mode))
#+END_SRC

**** Julia

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flycheck-julia
    :after (flycheck julia-mode)
    :hook (julia-mode . (lambda() (flycheck-julia-setup))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package julia-mode
    :mode ("\\.jl\\'" . julia-mode))
#+END_SRC

**** Lisp

#+BEGIN_SRC emacs-lisp :tangle config.el
  (add-hook 'lisp-mode-hook
            (lambda()
              (add-hook 'before-save-hook
                        (lambda() (untabify (point-min) (point-max)))
                        nil 'local)

              (setq-local c-basic-offset         8
                          indent-tabs-mode       nil
                          tab-width              8)))
#+END_SRC

**** Markdown

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package markdown-mode
    :init
    (add-hook 'markdown-mode-hook
              (lambda()
                (add-hook 'before-save-hook
                          (lambda() (untabify (point-min) (point-max)))
                          nil 'local)

                (setq-local c-basic-offset         4
                            indent-tabs-mode       nil
                            tab-width              4)))

    :mode ("\\.md\\'" . markdown-mode))
#+END_SRC

**** Meson

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package meson-mode
    :mode ("\\meson.build\\'" . meson-mode))
#+END_SRC

**** NGINX

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package nginx-mode
    :defer 't)
#+END_SRC

**** Ninja

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package ninja-mode
    :defer 't)
#+END_SRC

**** Org

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package org
    :bind (:map org-mode-map
                ([remap backward-paragraph] . nil)
                ([remap forward-paragraph]  . nil)
                ("C-S-<down>" . nil)
                ("C-S-<up>"   . nil)
                ("M-<down>"   . nil)
                ("M-<up>"     . nil)
                ("S-<left>"   . nil)
                ("S-<right>"  . nil))

    :config
    (setq org-src-fontify-natively  't
          org-src-tab-acts-natively 't
          org-support-shift-select  'always)

    (set-face-attribute 'org-block nil
                        :background "#111111" :extend 't)

    :hook ((org-metadown  . windmove-down)
           (org-metaleft  . windmove-left)
           (org-metaright . windmove-right)
           (org-metaup    . windmove-up)
           (org-mode . (lambda() (setq-local indent-tabs-mode nil))))

    :mode ("\\.org\\'" . org-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package org-bullets
    :commands (org-bullets-mode)
    :hook (org-mode . (lambda() (org-bullets-mode 1))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package org-drill
    :commands (org-drill)
    :defer 't)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package toc-org
    :after (org)
    :commands (toc-org-enable)
    :hook (org-mode . toc-org-enable))
#+END_SRC

**** PHP

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package company-php
    :after (company php-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package php-mode
    :mode ("\\.php\\'" . php-mode))
#+END_SRC

**** Protobuf

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package protobuf-mode
    :mode ("\\.proto\\'" . protobuf-mode))
#+END_SRC

**** Python

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package python-mode
    :mode ("\\.py\\'" . python-mode))
#+END_SRC

**** Rust

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package cargo
    :commands (cargo-minor-mode)
    :hook (rust-mode . cargo-minor-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package flycheck-rust
    :commands (flycheck-rust-setup)
    :init
    (with-eval-after-load 'rust-mode
      (add-hook 'flycheck-mode-hook #'flycheck-rust-setup)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package rust-mode
    :commands (rust-format-buffer rust-mode)
    :init
    (add-hook 'rust-mode-hook
              (lambda()
                (add-hook 'before-save-hook
                          (lambda() (untabify (point-min) (point-max)))
                          nil 'local)

                (setq-local c-basic-offset         4
                            indent-tabs-mode       nil
                            tab-width              4)))

    :mode ("\\.rs\\'" . rust-mode))
#+END_SRC

**** Shell

#+BEGIN_SRC emacs-lisp :tangle config.el
  (add-hook 'sh-mode-hook
            (lambda()
              (add-hook 'before-save-hook
                        (lambda() (untabify (point-min) (point-max)))
                        nil 'local)
              (setq-local indent-tabs-mode nil)))
#+END_SRC

**** Sed

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package sed-mode
    :mode ("\\.sed\\'" . sed-mode))
#+END_SRC

**** Verilog

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package verilog-mode
    :mode ("\\.v\\'" . verilog-mode))
#+END_SRC

**** YAML

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package yaml-mode
    :init
    (add-hook 'yaml-mode-hook
              (lambda()
                (add-hook 'before-save-hook
                          (lambda() (untabify (point-min) (point-max)))
                          nil 'local)

                (setq-local c-basic-offset         4
                            indent-tabs-mode       nil
                            tab-width              4)))

    :mode (("\\.clang-format\\'" . yaml-mode)
           ("\\.yaml\\'" . yaml-mode)
           ("\\.yml\\'"  . yaml-mode)))
#+END_SRC

**** Zig

#+BEGIN_SRC emacs-lisp :tangle config.el
  (use-package zig-mode
    :mode ("\\.zig\\'" . zig-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle config.el
  (provide 'config)
  ;;; config.el ends here
#+END_SRC
